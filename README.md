This is an open assignment for the course "Graph Theory and Its Applications", which is a programming implementation of algorithms related to graph theory.
# 图论部分算法编程应用
作者为《图论》10班-158-张龙涛，本次作业所有源码均可在此GitHub地址找到。https://github.com/zltyyds/Graph-theory/tree/main。
# 一、图序列判定算法（Havel-Hakimi算法）
Havel-Hakimi算法是用于判断一个度序列是否可以构成一张简单无向图（即没有重边和自环）的算法。它的原理基于不断地减少度序列中最大度数节点的度数，并确保剩余的部分仍然满足图的性质。下为算法具体步骤：
初始化:
函数接受一个度序列（degree Sequence），这是一个整数列表。
主算法循环:
删除所有零: 从度序列中移除所有值为0的元素。
判断空列表: 如果度序列为空，则返回True，表示这个度序列可以构造出一张图。
排序: 将度序列按降序排列。
提取并移除最大度数: 取度序列中的第一个元素n。
判断可行性: 如果n大于剩余度序列的长度，则返回False，表示这个度序列不可能构成一张图。
度数减少: 对度序列中的前n个元素都减去1。
 
# 二、单源最短路算法（Dijkstra算法）
Dijkstra算法是用于计算从单一源点到所有其他顶点的最短路径的贪心算法。其基本思想是，每次选择未访问节点中具有最小暂时距离的节点，并更新其邻接节点的距离，直到所有节点都被访问。从S0={u0}开始逐步构造一个由V的子集组成的递增序列, S0, S1, … Sv−1, 使得在第i步结束时, 由u0到Si的最短路均已知。下为算法步骤：
1.初始化：
设定一个距离数组dist，记录从源点到各顶点的最短距离，初始时设置为无穷大INF，表示距离未知。
设定一个前驱数组prev，记录各顶点在最短路径上的前驱顶点，初始时设置为NIL。
设定源点的距离为0，即dist[source] = 0。
将所有节点加入到一个未访问集合Q中。
2.从未访问集合中选择当前最短距离的顶点：
从Q中选择当前距离最小的顶点u，并将其从Q中移除。
3.更新邻接顶点的距离：
对于顶点u的每一个未访问邻接顶点v，计算从源点经过u到v的距离alt = dist[u] + weight(u, v)，其中weight(u, v)是边u到v的权重。
如果alt小于当前记录的dist[v]，则更新dist[v] = alt，并更新前驱顶点prev[v] = u，表示到达顶点v的最短路径目前是经过u。
4.重复步骤2和步骤3：
重复从未访问集合中选择具有最短暂时距离的顶点，并更新其邻接顶点的距离，直到所有顶点都被访问。
     
# 三、最小生成树算法（Kruskal算法）
Kruskal算法是一种用于找到加权无向图的最小生成树（MST）的方法。其基本思想是按边权重从小到大排序，逐步将边添加到生成树中但不形成环，直到生成树包含所有顶点。算法步骤如下：
边集合初始化：
从邻接矩阵中提取所有边，并按边的权重从小到大排序。
并查集初始化：
初始化并查集，用于检测添加边后是否形成环。
逐步加入边：
依次选择最小权重的边，如果加入该边不会形成环，则将其添加到最小生成树中。
重复上述步骤：
直到最小生成树包含n-1条边为止（其中n是顶点数）。     

# 四、点着色算法
点着色（Graph Coloring）问题是经典的图论问题。它的目标是给图的每个顶点赋予一个颜色，使得相邻顶点的颜色不同。根据课本给出的点着色算法，此贪心算法步骤如下：
初始化：
为每个顶点分配一个颜色数组，初始未着色（color = -1）。
初始化一个可用颜色列表。
贪心着色：
对图中的每个顶点按顺序进行处理：
检查该顶点的所有邻接顶点，并标记它们使用的颜色。
选择第一个可用颜色，将其赋予当前顶点。
更新邻接顶点的颜色标记。

# 五、二部图最大匹配算法（匈牙利算法）
匈牙利算法（Hungarian Algorithm，也称为Kuhn-Munkres算法）用于解决二分图的最大匹配问题。它基于增广路径的思想来获得图的最大匹配。
1.初始化：
将所有顶点标记为未匹配。
创建表示匹配关系的数组。
2.寻找增广路径：
对于每个未匹配的顶点，尝试寻找一条增广路径，通过扩展和交替路径来增加匹配数。
使用深度优先搜索（DFS）来探索增广路径。
3.更新匹配：
如果找到增广路径，则更新匹配关系。
4.重复1和2步骤直到没有增广路径：
当无法找到新的增广路径时，算法结束，此时匹配数为最大匹配。
   
算法输出结果与吕老师PPT中给出的相同。
